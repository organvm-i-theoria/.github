name: Docker Build and Push

on:
  push:
    branches:
      - main
    paths:
      - 'Dockerfile'
      - 'docker-compose.yml'
      - 'docker-compose.yaml'
  workflow_dispatch:
  workflow_call:

permissions:
  contents: write
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-dockerfile:
    runs-on: ubuntu-latest
    outputs:
      has_dockerfile: ${{ steps.check.outputs.has_dockerfile }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for Dockerfile
        id: check
        run: |
          if [ -f "Dockerfile" ]; then
            echo "has_dockerfile=true" >> $GITHUB_OUTPUT
            echo "Dockerfile found"
          else
            echo "has_dockerfile=false" >> $GITHUB_OUTPUT
            echo "No Dockerfile found"
          fi

  build-and-push:
    needs: check-dockerfile
    if: needs.check-dockerfile.outputs.has_dockerfile == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD'}}-{{sha}}

      - name: Detect application port
        id: port
        run: |
          PORT="3000"
          
          # Check Dockerfile for EXPOSE directive
          if grep -q "^EXPOSE" Dockerfile; then
            PORT=$(grep "^EXPOSE" Dockerfile | awk '{print $2}' | head -1)
          fi
          
          # Check package.json for common ports
          if [ -f "package.json" ]; then
            if grep -q "\"express\"" package.json; then
              PORT="3000"
            fi
          fi
          
          # Check for Python frameworks
          if [ -f "requirements.txt" ]; then
            if grep -q "flask" requirements.txt; then
              PORT="5000"
            elif grep -q "fastapi\|uvicorn" requirements.txt; then
              PORT="8000"
            elif grep -q "django" requirements.txt; then
              PORT="8000"
            fi
          fi
          
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "Detected port: $PORT"

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}

      - name: Generate run instructions
        run: |
          cat > DOCKER_RUN.md << 'EOF'
          # Docker Run Instructions
          
          ## Pull the image
          
          ```bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ```
          
          ## Run the container
          
          ```bash
          docker run -d \
            --name ${{ github.event.repository.name }} \
            -p ${{ steps.port.outputs.port }}:${{ steps.port.outputs.port }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ```
          
          ## Access the application
          
          Open your browser to: http://localhost:${{ steps.port.outputs.port }}
          
          ## View logs
          
          ```bash
          docker logs -f ${{ github.event.repository.name }}
          ```
          
          ## Stop the container
          
          ```bash
          docker stop ${{ github.event.repository.name }}
          docker rm ${{ github.event.repository.name }}
          ```
          
          ## Environment Variables
          
          Set environment variables with `-e` flag:
          
          ```bash
          docker run -d \
            --name ${{ github.event.repository.name }} \
            -p ${{ steps.port.outputs.port }}:${{ steps.port.outputs.port }} \
            -e NODE_ENV=production \
            -e DATABASE_URL=your_database_url \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ```
          
          ## Docker Compose (if available)
          
          ```bash
          docker-compose up -d
          ```
          
          ## Available Tags
          
          - `latest` - Latest stable build from main branch
          - `main` - Latest build from main branch
          - `sha-<commit>` - Specific commit builds
          - `YYYYMMDD-<sha>` - Date-stamped builds
          
          ## Registry
          
          View all tags: https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}
          EOF
          
          echo "Docker run instructions created"
          cat DOCKER_RUN.md

      - name: Store application metadata
        run: |
          cat > docker-metadata.json << EOF
          {
            "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}",
            "tags": ${{ steps.meta.outputs.json }},
            "port": "${{ steps.port.outputs.port }}",
            "digest": "${{ steps.build.outputs.digest }}",
            "build_date": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "repository": "${{ github.repository }}",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}"
          }
          EOF
          
          echo "Metadata stored in docker-metadata.json"
          cat docker-metadata.json

      - name: Create deployment manifest
        run: |
          mkdir -p .github/deployments
          
          cat > .github/deployments/docker.yml << EOF
          # Docker Deployment Manifest
          # Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          port: ${{ steps.port.outputs.port }}
          
          environment:
            - NODE_ENV=production
            - PORT=${{ steps.port.outputs.port }}
          
          volumes:
            - ./data:/app/data
          
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:${{ steps.port.outputs.port }}/health"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 40s
          
          restart: unless-stopped
          
          labels:
            com.github.repository: "${{ github.repository }}"
            com.github.sha: "${{ github.sha }}"
            com.github.ref: "${{ github.ref }}"
          EOF
          
          echo "Deployment manifest created"

      - name: Update app deployment registry
        run: |
          mkdir -p docs/_data
          
          # Create or append to app-deployments.yml
          if [ ! -f "docs/_data/app-deployments.yml" ]; then
            echo "apps:" > docs/_data/app-deployments.yml
          fi
          
          cat >> docs/_data/app-deployments.yml << EOF
            - app_name: "${{ github.event.repository.name }}"
              deployment_strategy: "docker"
              docker_image: "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
              port: "${{ steps.port.outputs.port }}"
              status: "deployed"
              last_updated: "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
              registry_url: "https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}"
          EOF

      - name: Commit deployment files
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add DOCKER_RUN.md docker-metadata.json .github/deployments/ docs/_data/
          
          if ! git diff --staged --quiet; then
            git commit -m "chore: Update Docker deployment files [skip ci]"
            git push
          fi

      - name: Log deployment details
        run: |
          echo "::notice::Docker image built and pushed successfully"
          echo "::notice::Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "::notice::Port: ${{ steps.port.outputs.port }}"
          echo "::notice::Digest: ${{ steps.build.outputs.digest }}"
          echo "::notice::Run command: docker run -d -p ${{ steps.port.outputs.port }}:${{ steps.port.outputs.port }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

      - name: Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Docker Build Summary
          
          ## Image Details
          
          - **Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
          - **Port**: \`${{ steps.port.outputs.port }}\`
          - **Digest**: \`${{ steps.build.outputs.digest }}\`
          - **Build Date**: \`$(date -u +"%Y-%m-%d %H:%M:%S UTC")\`
          
          ## Quick Start
          
          \`\`\`bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker run -d -p ${{ steps.port.outputs.port }}:${{ steps.port.outputs.port }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          \`\`\`
          
          ## Registry
          
          View all tags: [Container Registry](https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }})
          
          ## Documentation
          
          See [DOCKER_RUN.md](./DOCKER_RUN.md) for detailed run instructions.
          EOF

  skip-build:
    needs: check-dockerfile
    if: needs.check-dockerfile.outputs.has_dockerfile == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Log skip reason
        run: |
          echo "No Dockerfile found in repository"
          echo "Docker build skipped"
          echo "To enable Docker deployment, add a Dockerfile to your repository"
