name: AgentSphere Live Demo Deployment

on:
  push:
    branches:
      - main
      - master
    paths:
      - "**.py"
      - "**.js"
      - "**.ts"
      - "**.jsx"
      - "**.tsx"
      - "**.html"
      - "**.css"
      - "requirements*.txt"
      - "package*.json"
      - "Dockerfile"
      - "docker-compose.yml"
      - ".github/workflows/agentsphere-deployment.yml"
  workflow_dispatch:
    inputs:
      force_deploy:
        description: Force deployment even if app type cannot be detected
        required: false
        type: boolean
        default: false
      custom_command:
        description: Custom startup command (optional)
        required: false
        type: string
  workflow_call:
    inputs:
      force_deploy:
        description: Force deployment even if app type cannot be detected
        required: false
        type: boolean
        default: false
      custom_command:
        description: Custom startup command (optional)
        required: false
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  detect-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load AgentSphere configuration
        id: load-config
        run: |
          CONFIG_FILE=".github/agentsphere-config.yml"

          if [ ! -f "$CONFIG_FILE" ]; then
            echo "‚ùå AgentSphere configuration file not found"
            echo "enabled=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if enabled
          ENABLED=$(yq eval '.enabled' "$CONFIG_FILE")
          echo "enabled=$ENABLED" >> $GITHUB_OUTPUT

          if [ "$ENABLED" != "true" ]; then
            echo "‚è≠Ô∏è AgentSphere deployment is disabled"
            exit 0
          fi

          # Load global settings
          API_ENDPOINT=$(yq eval '.global.api_endpoint' "$CONFIG_FILE")
          STARTUP_TIMEOUT=$(yq eval '.global.startup_timeout' "$CONFIG_FILE")
          BADGE_STYLE=$(yq eval '.global.badge.style' "$CONFIG_FILE")
          BADGE_POSITION=$(yq eval '.global.badge.position' "$CONFIG_FILE")

          echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
          echo "startup_timeout=$STARTUP_TIMEOUT" >> $GITHUB_OUTPUT
          echo "badge_style=$BADGE_STYLE" >> $GITHUB_OUTPUT
          echo "badge_position=$BADGE_POSITION" >> $GITHUB_OUTPUT

      - name: Detect application type
        id: detect-app
        if: steps.load-config.outputs.enabled == 'true'
        env:
          INPUT_CUSTOM_COMMAND: ${{ inputs.custom_command }}
          EVENT_CUSTOM_COMMAND: ${{ github.event.inputs.custom_command }}
          INPUT_FORCE_DEPLOY: ${{ inputs.force_deploy }}
          EVENT_FORCE_DEPLOY: ${{ github.event.inputs.force_deploy }}
        run: |
          echo "üîç Detecting application type..."

          APP_TYPE=""
          STARTUP_CMD=""
          PORT=""
          BUILD_CMD=""

          FORCE_DEPLOY_INPUT="$INPUT_FORCE_DEPLOY"
          if [ -z "$FORCE_DEPLOY_INPUT" ]; then
            FORCE_DEPLOY_INPUT="$EVENT_FORCE_DEPLOY"
          fi

          # Check for Node.js
          if [ -f "package.json" ]; then
            echo "‚úì Detected Node.js application (package.json found)"

            # Detect specific framework
            if [ -f "vue.config.js" ] || grep -q '"vue"' package.json 2>/dev/null; then
              APP_TYPE="vue"
              echo "  ‚Üí Vue.js application"
            elif grep -q '"react"' package.json 2>/dev/null || [ -f "src/App.jsx" ] || [ -f "src/App.tsx" ]; then
              APP_TYPE="react"
              echo "  ‚Üí React application"
            else
              APP_TYPE="nodejs"
              echo "  ‚Üí Generic Node.js application"
            fi

            # Determine startup command from package.json scripts
            if grep -q '"start"' package.json; then
              STARTUP_CMD="npm start"
            elif grep -q '"dev"' package.json; then
              STARTUP_CMD="npm run dev"
            elif grep -q '"serve"' package.json; then
              STARTUP_CMD="npm run serve"
            else
              STARTUP_CMD="node index.js"
            fi

            BUILD_CMD="npm install"
            PORT="3000"

          # Check for Python
          elif [ -f "requirements.txt" ] || [ -f "Pipfile" ] || [ -f "pyproject.toml" ] || [ -f "setup.py" ]; then
            APP_TYPE="python"
            echo "‚úì Detected Python application"

            if [ -f "app.py" ]; then
              STARTUP_CMD="python app.py"
            elif [ -f "main.py" ]; then
              STARTUP_CMD="python main.py"
            elif grep -q "flask" requirements.txt 2>/dev/null; then
              STARTUP_CMD="python -m flask run --host=0.0.0.0"
            elif grep -q "fastapi" requirements.txt 2>/dev/null; then
              STARTUP_CMD="uvicorn app:app --host 0.0.0.0 --port 8000"
            elif grep -q "django" requirements.txt 2>/dev/null; then
              STARTUP_CMD="python manage.py runserver 0.0.0.0:8000"
            else
              STARTUP_CMD="python app.py"
            fi

            BUILD_CMD="pip install -r requirements.txt"
            PORT="8000"

          # Check for Java
          elif [ -f "pom.xml" ] || [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            APP_TYPE="java"
            echo "‚úì Detected Java application"

            if [ -f "pom.xml" ]; then
              BUILD_CMD="mvn clean install -DskipTests"
              STARTUP_CMD="java -jar target/*.jar"
            elif [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
              BUILD_CMD="gradle build -x test"
              STARTUP_CMD="gradle bootRun"
            fi

            PORT="8080"

          # Check for Go
          elif [ -f "go.mod" ] || [ -f "main.go" ]; then
            APP_TYPE="go"
            echo "‚úì Detected Go application"

            BUILD_CMD="go build -o main ."
            STARTUP_CMD="./main"
            PORT="8080"

          # Check for Ruby
          elif [ -f "Gemfile" ] || [ -f "config.ru" ]; then
            APP_TYPE="ruby"
            echo "‚úì Detected Ruby application"

            BUILD_CMD="bundle install"
            if [ -f "config.ru" ]; then
              STARTUP_CMD="bundle exec puma -p 3000"
            else
              STARTUP_CMD="ruby app.rb"
            fi
            PORT="3000"

          # Check for .NET
          elif ls *.csproj 1> /dev/null 2>&1 || ls *.sln 1> /dev/null 2>&1; then
            APP_TYPE="dotnet"
            echo "‚úì Detected .NET application"

            BUILD_CMD="dotnet restore && dotnet build"
            STARTUP_CMD="dotnet run"
            PORT="5000"

          else
            echo "‚ùå Could not detect application type"
            APP_TYPE="unknown"
          fi

          # Use custom command if provided
          CUSTOM_CMD="$INPUT_CUSTOM_COMMAND"
          if [ -z "$CUSTOM_CMD" ]; then
            CUSTOM_CMD="$EVENT_CUSTOM_COMMAND"
          fi
          if [ -n "$CUSTOM_CMD" ]; then
            STARTUP_CMD="$CUSTOM_CMD"
            echo "  ‚Üí Using custom startup command: $STARTUP_CMD"
          fi

          # Output results
          echo "app_type=$APP_TYPE" >> $GITHUB_OUTPUT
          echo "startup_command=$STARTUP_CMD" >> $GITHUB_OUTPUT
          echo "build_command=$BUILD_CMD" >> $GITHUB_OUTPUT
          echo "port=$PORT" >> $GITHUB_OUTPUT

          if [ "$APP_TYPE" = "unknown" ] && [ "$FORCE_DEPLOY_INPUT" != "true" ]; then
            echo "‚ö†Ô∏è Deployment skipped - unknown application type"
            exit 1
          fi

      - name: Register with AgentSphere
        id: register
        if: steps.detect-app.outputs.app_type != 'unknown' || inputs.force_deploy == true || github.event.inputs.force_deploy == 'true'
        run: |
          echo "‚ö†Ô∏è  =============================================="
          echo "‚ö†Ô∏è  SIMULATION MODE - AgentSphere Integration"
          echo "‚ö†Ô∏è  =============================================="
          echo ""
          echo "üìù This workflow is currently in SIMULATION mode."
          echo "üìù Generated URLs are for demonstration and testing purposes only."
          echo "üìù To implement real AgentSphere integration, see:"
          echo "üìù   - WORKFLOW_OPTIMIZATION_ROADMAP.md"
          echo "üìù   - NEXT_STEPS_IMPLEMENTATION.md"
          echo ""
          echo "üöÄ Simulating AgentSphere registration..."

          API_ENDPOINT="${{ steps.load-config.outputs.api_endpoint }}"
          REPO_NAME="${{ github.repository }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          COMMIT_SHA="${{ github.sha }}"

          # Prepare deployment payload
          PAYLOAD=$(cat <<EOF
          {
            "repository": "$REPO_NAME",
            "repository_url": "$REPO_URL",
            "commit_sha": "$COMMIT_SHA",
            "branch": "${{ github.ref_name }}",
            "app_type": "${{ steps.detect-app.outputs.app_type }}",
            "startup_command": "${{ steps.detect-app.outputs.startup_command }}",
            "build_command": "${{ steps.detect-app.outputs.build_command }}",
            "port": "${{ steps.detect-app.outputs.port }}",
            "timeout": ${{ steps.load-config.outputs.startup_timeout }}
          }
          EOF
          )

          # NOTE: In production, this would make an actual API call to AgentSphere
          # For now, we'll simulate the response
          echo "üì° Simulating AgentSphere API call (not making real request)..."
          echo "$PAYLOAD" | jq .

          # Simulate successful deployment
          DEMO_URL="https://demo-${REPO_NAME//\//-}.agentsphere.dev"
          DEMO_ID="demo_$(date +%s)_${RANDOM}"

          echo ""
          echo "‚úÖ Simulation completed successfully!"
          echo "   Simulated Demo URL: $DEMO_URL"
          echo "   Simulated Demo ID: $DEMO_ID"
          echo ""
          echo "‚ö†Ô∏è  Note: These URLs are simulated and non-functional"

          echo "demo_url=$DEMO_URL" >> $GITHUB_OUTPUT
          echo "demo_id=$DEMO_ID" >> $GITHUB_OUTPUT
          echo "deployment_status=success" >> $GITHUB_OUTPUT

      - name: Generate README badge
        id: generate-badge
        if: steps.register.outputs.deployment_status == 'success'
        run: |
          DEMO_URL="${{ steps.register.outputs.demo_url }}"
          BADGE_STYLE="${{ steps.load-config.outputs.badge_style }}"

          # Generate badge markdown
          BADGE_MD="[![Live Demo](https://img.shields.io/badge/Live%20Demo-Available-brightgreen?style=${BADGE_STYLE})](${DEMO_URL})"

          echo "badge_markdown<<EOF" >> $GITHUB_OUTPUT
          echo "$BADGE_MD" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Generated badge: $BADGE_MD"

      - name: Update README with badge
        if: steps.register.outputs.deployment_status == 'success'
        run: |
          if [ ! -f "README.md" ]; then
            echo "‚ö†Ô∏è README.md not found, skipping badge insertion"
            exit 0
          fi

          BADGE="${{ steps.generate-badge.outputs.badge_markdown }}"
          POSITION="${{ steps.load-config.outputs.badge_position }}"

          # Check if badge already exists
          if grep -q "Live Demo" README.md; then
            echo "‚ÑπÔ∏è Badge already exists in README.md"
            exit 0
          fi

          # Insert badge based on position
          if [ "$POSITION" = "top" ]; then
            # Insert at the very top
            echo -e "$BADGE\n\n$(cat README.md)" > README.md
          elif [ "$POSITION" = "after-title" ]; then
            # Insert after the first heading (using | as delimiter to avoid conflicts with URLs)
            sed -i "0,/^#/s|^\(#.*\)|\1\n\n$BADGE|" README.md
          else
            # Default: insert at top
            echo -e "$BADGE\n\n$(cat README.md)" > README.md
          fi

          echo "‚úÖ Badge added to README.md"

      - name: Create pull request
        if: steps.register.outputs.deployment_status == 'success'
        uses: peter-evans/create-pull-request@5e914681df9dc83aa4e4905692ca88beb2f9e91f # ratchet:peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: add AgentSphere live demo badge to README (SIMULATION)"
          title: üöÄ Add Live Demo Badge (Simulation Mode)
          body: |
            ## ‚ö†Ô∏è Live Demo Deployment (SIMULATION MODE)

            **Important**: This workflow is currently in **simulation mode**. The generated URLs are for demonstration and testing purposes only and do not point to actual live deployments.

            ### Simulated Deployment Information

            **Simulated Demo URL:** ${{ steps.register.outputs.demo_url }}
            **Simulated Demo ID:** ${{ steps.register.outputs.demo_id }}
            **Application Type:** ${{ steps.detect-app.outputs.app_type }}
            **Startup Command:** `${{ steps.detect-app.outputs.startup_command }}`

            This PR adds a "Live Demo" badge to the README. However, **the badge links to a simulated URL that is not functional**.

            ---

            ### To Implement Real AgentSphere Integration

            See the implementation guides:
            - `WORKFLOW_OPTIMIZATION_ROADMAP.md` - Complete implementation plan
            - `NEXT_STEPS_IMPLEMENTATION.md` - Step-by-step instructions
            - Week 2-4 tasks include real API integration

            ---

            ### What's Next?

            - ‚úÖ Review the live demo to ensure it's working correctly
            - ‚úÖ Merge this PR to make the badge visible
            - ‚úÖ Share the demo URL with stakeholders

            ### Troubleshooting

            If the demo isn't working as expected, check the [AgentSphere Setup Guide](.github/docs/AGENTSPHERE_SETUP.md).

            ---

            _Automated by [AgentSphere Deployment Workflow](.github/workflows/agentsphere-deployment.yml)_
          branch: agentsphere/add-live-demo-badge
          delete-branch: true

      - name: Deployment summary
        if: always()
        run: |
          echo "## AgentSphere Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.load-config.outputs.enabled }}" != "true" ]; then
            echo "‚è≠Ô∏è **Status:** Disabled" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          if [ "${{ steps.register.outputs.deployment_status }}" = "success" ]; then
            echo "‚úÖ **Status:** Deployment Successful" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Application Type:** ${{ steps.detect-app.outputs.app_type }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Demo URL:** [${{ steps.register.outputs.demo_url }}](${{ steps.register.outputs.demo_url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **Startup Command:** \`${{ steps.detect-app.outputs.startup_command }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Port:** ${{ steps.detect-app.outputs.port }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Status:** Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Could not detect application type. Use manual deployment with custom command." >> $GITHUB_STEP_SUMMARY
          fi
