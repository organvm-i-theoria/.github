name: AI Task Orchestrator

on:
  schedule:
    - cron: '*/15 * * * *' # Runs every 15 minutes

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # ratchet:actions/checkout@v4.2.2

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # ratchet:actions/setup-python@v5.3.0
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install croniter

      - name: Run Orchestrator
        id: orchestrator
        run: |
          python3 << 'EOF'
          python << 'EOF'
          import json
          import os
          from datetime import datetime
          from croniter import croniter

          now = datetime.now()
          tasks = json.load(open('.github/orchestration_tasks.json'))['tasks']
          due_tasks = []

          for task in tasks:
              if task['enabled'] and croniter.is_valid(task['schedule']):
                  base_time = now
                  cron = croniter(task['schedule'], base_time)

                  # Check if a scheduled run occurred in the last 15 minutes
                  # To do this, we get the time of the previous scheduled run
                  prev_run = cron.get_prev(datetime)

                  # Now, we check if that previous run time is within the last 15 minutes
                  if (now - prev_run).total_seconds() <= 900: # 15 minutes * 60 seconds
                      due_tasks.append(task)

          print(f"{len(due_tasks)} tasks due to run.")

          # Correctly format the JSON for the output
          due_tasks_json = json.dumps({"tasks": due_tasks})
          print(due_tasks_json)
          
          # Write to GITHUB_OUTPUT
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write('due_tasks<<EOF\n')
              f.write(f"{due_tasks_json}\n")
              f.write('EOF\n')
              f.write(f"due_tasks={due_tasks_json}\n")
          EOF

      - name: Dispatch Due Tasks
        if: steps.orchestrator.outputs.due_tasks != '{"tasks":[]}'
        run: |
          echo '${{ steps.orchestrator.outputs.due_tasks }}' | jq -c '.tasks[]' | while read -r task; do
            subscription_name=$(echo "$task" | jq -r '.subscription')
            task_id=$(echo "$task" | jq -r '.id')
            prompt=$(echo "$task" | jq -r '.prompt')
            
            # Check for task deduplication
            TASK_DATA=$(echo "$task" | jq -c '{id, subscription, prompt}')
            DEDUPE_RESULT=$(python3 .github/scripts/task_deduplicator.py check "orchestrated_task" "$TASK_DATA" || echo '{"should_process":true,"reason":"script error"}')
            SHOULD_PROCESS=$(echo "$DEDUPE_RESULT" | jq -r '.should_process')
            REASON=$(echo "$DEDUPE_RESULT" | jq -r '.reason')
            
            if [ "$SHOULD_PROCESS" = "false" ]; then
              echo "⏭️  Skipping duplicate task $task_id: $REASON"
              continue
            fi
            
            # Check quota
            usage=$(python scripts/quota_manager.py get_usage "$subscription_name")
            quota=$(jq -r --arg name "$subscription_name" '.subscriptions[] | select(.name==$name) | .quota' .github/subscriptions.json)

            if (( $(echo "$usage < $quota" | bc -l) )); then
              echo "Dispatching task: $task_id"
              workflow_file=$(jq -r --arg name "$subscription_name" '.subscriptions[] | select(.name==$name) | .relevant_workflows[0]' .github/subscriptions.json)

              if [ -n "$workflow_file" ] && [ "$workflow_file" != "null" ]; then
                gh workflow run "$workflow_file" --ref ${{ github.ref }} -f "prompt=$prompt"
                # Note: The increment of usage will be handled by the individual workflows
              else
                echo "No relevant workflow found for subscription: $subscription_name"
              fi
            else
              echo "Skipping task $task_id: Quota limit reached for $subscription_name."
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
