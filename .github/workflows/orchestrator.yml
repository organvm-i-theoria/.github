name: AI Task Orchestrator

on:
  schedule:
  - cron: '*/15 * * * *'   # Runs every 15 minutes
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
    - name: Checkout repository
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # ratchet:actions/checkout@v4.2.2
      with:
        fetch-depth: 0   # Need full history for branch operations

    - name: Set up Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065  # ratchet:actions/setup-python@v5.3.0
      with:
        python-version: "3.12"

    - name: Install dependencies
      run: pip install croniter

    - name: Run Orchestrator
      id: orchestrator
      run: |
        import json
        import os
        from datetime import datetime
        from croniter import croniter

        now = datetime.now()
        # Load tasks safely
        try:
            with open('.github/orchestration_tasks.json', 'r') as f:
                tasks = json.load(f).get('tasks', [])
        except FileNotFoundError:
            tasks = []
            print("No orchestration tasks file found.")

        due_tasks = []

        for task in tasks:
            if task.get('enabled') and croniter.is_valid(task.get('schedule')):
                base_time = now
                cron = croniter(task['schedule'], base_time)

                # Check if a scheduled run occurred in the last 15 minutes
                prev_run = cron.get_prev(datetime)

                # Use strictly less than 900 to avoid double-triggering at exactly 15m mark
                if (now - prev_run).total_seconds() < 900:
                    due_tasks.append(task)

        print(f"{len(due_tasks)} tasks due to run.")

        # Format output
        due_tasks_json = json.dumps({"tasks": due_tasks})
        has_tasks = str(len(due_tasks) > 0).lower()

        # Write to GITHUB_OUTPUT
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"due_tasks={due_tasks_json}\n")
            f.write(f"has_tasks={has_tasks}\n")
      shell: python

    - name: Setup Daily Batch Branch
      if: steps.orchestrator.outputs.has_tasks == 'true'
      id: setup_branch
      run: |
        # Define branch name based on date
        DAILY_BRANCH="daily-batch-$(date +%Y-%m-%d)"
        echo "DAILY_BRANCH=$DAILY_BRANCH" >> $GITHUB_ENV

        # Configure git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        # Check if remote branch exists
        if git ls-remote --exit-code --heads origin "$DAILY_BRANCH"; then
          echo "Branch $DAILY_BRANCH already exists."
          git fetch origin "$DAILY_BRANCH"
          git checkout "$DAILY_BRANCH"
        else
          echo "Creating branch $DAILY_BRANCH from main..."
          git fetch origin main
          git checkout -b "$DAILY_BRANCH" origin/main
          git push origin "$DAILY_BRANCH"
        fi

        # Ensure a PR exists
        pr_view_output=""
        if pr_view_output=$(gh pr view "$DAILY_BRANCH" --json url 2>&1); then
          echo "PR already exists."
        else
          # Distinguish 'PR not found' from other errors to aid debugging
          if echo "$pr_view_output" | grep -qi "not found"; then
            echo "No existing PR found for $DAILY_BRANCH. Creating daily PR..."
            gh pr create \
              --base main \
              --head "$DAILY_BRANCH" \
              --title "üìÖ Daily Batch Updates: $(date +%Y-%m-%d)" \
              --body $'This is an automated daily batch PR collecting tasks performed by AI agents.\n\n## üìù Task Checklist\n\n- [ ] Daily tasks verification\n\n_Auto-generated by AI Task Orchestrator_' \
              --draft
          else
            echo "Error while checking for existing PR on branch $DAILY_BRANCH:"
            echo "$pr_view_output"
            exit 1
          fi
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Dispatch Due Tasks
      if: steps.orchestrator.outputs.has_tasks == 'true'
      run: |
        echo '${{ steps.orchestrator.outputs.due_tasks }}' | jq -c '.tasks[]' | while read -r task; do
          subscription_name=$(echo "$task" | jq -r '.subscription')
          task_id=$(echo "$task" | jq -r '.id')
          prompt=$(echo "$task" | jq -r '.prompt')

          # Check for task deduplication
          TASK_DATA=$(echo "$task" | jq -c '{id, subscription, prompt}')
          DEDUPE_RESULT=$(python3 .github/scripts/task_deduplicator.py check "orchestrated_task" "$TASK_DATA" || echo '{"should_process":false,"reason":"script error"}')
          SHOULD_PROCESS=$(echo "$DEDUPE_RESULT" | jq -r '.should_process')
          REASON=$(echo "$DEDUPE_RESULT" | jq -r '.reason')

          if [ "$SHOULD_PROCESS" = "false" ]; then
            echo "‚è≠Ô∏è  Skipping duplicate task $task_id: $REASON"
            continue
          fi

          # Check quota
          usage=$(python src/automation/scripts/quota_manager.py get_usage "$subscription_name")
          quota=$(jq -r --arg name "$subscription_name" '.subscriptions[] | select(.name==$name) | .quota' .github/subscriptions.json)

          if (( $(echo "$usage < $quota" | bc -l) )); then
            echo "Dispatching task: $task_id"
            workflow_file=$(jq -r --arg name "$subscription_name" '.subscriptions[] | select(.name==$name) | .relevant_workflows[0]' .github/subscriptions.json)

            if [ -n "$workflow_file" ] && [ "$workflow_file" != "null" ]; then
              # Dispatch workflow on the daily batch branch
              gh workflow run "$workflow_file" --ref "$DAILY_BRANCH" -f "prompt=$prompt"
              echo "‚úÖ Triggered $workflow_file on $DAILY_BRANCH"
            else
              echo "No relevant workflow found for subscription: $subscription_name"
            fi
          else
            echo "Skipping task $task_id: Quota limit reached for $subscription_name."
          fi
        done
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
