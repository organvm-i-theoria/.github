name: Proactive Maintenance

on:
  schedule:
    # Run every Sunday at 3 AM UTC
  - cron: 0 3 * * 0

  workflow_dispatch:
    inputs:
      maintenance_type:
        description: Type of maintenance to run
        required: false
        type: choice
        options:
        - all
        - dependencies
        - cleanup
        - optimization
        default: all
      dry_run:
        description: Dry run mode (no changes)
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  DRY_RUN: ${{ inputs.dry_run || 'false' }}

jobs:
  analyze-maintenance-needs:
    name: Analyze Maintenance Needs
    runs-on: ubuntu-latest
    outputs:
      needs_dependency_update: ${{ steps.analyze.outputs.needs_dependency_update }}
      needs_cleanup: ${{ steps.analyze.outputs.needs_cleanup }}
      needs_optimization: ${{ steps.analyze.outputs.needs_optimization }}
      maintenance_window: ${{ steps.analyze.outputs.maintenance_window }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Analyze repository activity
      id: analyze
      run: |
        # Predict optimal maintenance window based on activity patterns
        # (In production, this would use ML predictions)
        CURRENT_HOUR=$(date +%H)
        LOW_ACTIVITY_HOURS="true"  # Sunday 3 AM is typically low activity

        # Check for outdated dependencies
        NEEDS_DEPS="false"
        if [[ -f "requirements.txt" ]]; then
          # Check if dependencies are outdated (simplified check)
          NEEDS_DEPS="true"
        fi
        if [[ -f "package.json" ]]; then
          NEEDS_DEPS="true"
        fi

        # Check for cleanup needs (stale branches, old artifacts)
        STALE_BRANCHES=$(git branch -r --merged origin/main 2>/dev/null | grep -v main | wc -l || echo "0")
        NEEDS_CLEANUP="false"
        if [[ $STALE_BRANCHES -gt 5 ]]; then
          NEEDS_CLEANUP="true"
        fi

        # Check for optimization needs
        NEEDS_OPT="true"  # Always beneficial

        echo "needs_dependency_update=$NEEDS_DEPS" >> $GITHUB_OUTPUT
        echo "needs_cleanup=$NEEDS_CLEANUP" >> $GITHUB_OUTPUT
        echo "needs_optimization=$NEEDS_OPT" >> $GITHUB_OUTPUT
        echo "maintenance_window=$LOW_ACTIVITY_HOURS" >> $GITHUB_OUTPUT

        echo "::notice title=Maintenance Analysis::Dependencies: $NEEDS_DEPS, Cleanup: $NEEDS_CLEANUP, Optimization: $NEEDS_OPT"

  update-dependencies:
    name: Update Dependencies
    runs-on: ubuntu-latest
    needs: analyze-maintenance-needs
    if: |
      (needs.analyze-maintenance-needs.outputs.needs_dependency_update == 'true' ||
       inputs.maintenance_type == 'dependencies' ||
       inputs.maintenance_type == 'all')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Update Python dependencies
      if: hashFiles('requirements.in') != ''
      run: |
        if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
          echo "DRY RUN: Would update Python dependencies"
          pip list --outdated
        else
          pip install pip-tools
          pip-compile --upgrade requirements.in
        fi

    - name: Update npm dependencies
      if: hashFiles('package.json') != ''
      run: |
        if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
          echo "DRY RUN: Would update npm dependencies"
          npm outdated || true
        else
          npm update
        fi

    - name: Create dependency update PR
      if: env.DRY_RUN != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        if [[ -n "$(git status --porcelain)" ]]; then
          # Configure git for commits
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          BRANCH="maintenance/dependency-updates-$(date +%Y%m%d)"
          git checkout -b $BRANCH
          git add -A
          git commit -m "chore: update dependencies

        Automated dependency updates from proactive maintenance workflow."
          git push origin $BRANCH

          gh pr create \
            --title "ðŸ”„ Automated Dependency Updates" \
            --body "## Dependency Updates

        This PR contains automated dependency updates from the proactive maintenance workflow.

        **Maintenance Window:** $(date -u +"%Y-%m-%d %H:%M UTC")

        Please review and merge when ready.

        ---
        *Created by Proactive Maintenance workflow*" \
            --label "dependencies,automation"
        fi

  perform-cleanup:
    name: Perform Cleanup
    runs-on: ubuntu-latest
    needs: analyze-maintenance-needs
    if: |
      (needs.analyze-maintenance-needs.outputs.needs_cleanup == 'true' ||
       inputs.maintenance_type == 'cleanup' ||
       inputs.maintenance_type == 'all')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Clean stale branches
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Identifying stale branches..."

        # Find merged branches
        MERGED_BRANCHES=$(git branch -r --merged origin/main | grep -v 'main\|HEAD' | sed 's/origin\///' || true)

        if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
          echo "DRY RUN: Would delete these branches:"
          echo "$MERGED_BRANCHES"
        else
          for branch in $MERGED_BRANCHES; do
            echo "Deleting merged branch: $branch"
            git push origin --delete "$branch" 2>/dev/null || true
          done
        fi

    - name: Clean old workflow runs
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "Cleaning old workflow runs..."

        if [[ "${{ env.DRY_RUN }}" == "true" ]]; then
          echo "DRY RUN: Would clean old workflow runs older than 30 days, keeping the 100 most recent"
        else
          # Get runs, skip first 100 (keep them), then delete only those older than 30 days
          gh run list --limit 300 --json databaseId,createdAt \
            | jq -r '.[100:] | .[] | select(.createdAt < (now - 2592000 | strftime("%Y-%m-%dT%H:%M:%SZ"))) | .databaseId' \
            | xargs -I {} gh run delete {} 2>/dev/null || true
        fi

    - name: Track cleanup metric
      run: |
        echo "::notice title=Maintenance Cleanup::Cleanup operations completed"

  run-optimization:
    name: Run Optimization
    runs-on: ubuntu-latest
    needs: analyze-maintenance-needs
    if: |
      (needs.analyze-maintenance-needs.outputs.needs_optimization == 'true' ||
       inputs.maintenance_type == 'optimization' ||
       inputs.maintenance_type == 'all')

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Analyze codebase for optimization
      run: |
        echo "Analyzing codebase for optimization opportunities..."

        # Check for large files
        LARGE_FILES=$(find . -type f -size +1M -not -path "./.git/*" | head -10)
        if [[ -n "$LARGE_FILES" ]]; then
          echo "Found large files that could be optimized:"
          echo "$LARGE_FILES"
        fi

        # Check for duplicate files
        if command -v fdupes &> /dev/null; then
          DUPLICATES=$(fdupes -r . --noempty 2>/dev/null | head -20)
          if [[ -n "$DUPLICATES" ]]; then
            echo "Found potential duplicate files"
          fi
        fi

        echo "::notice title=Optimization Analysis::Analysis complete"

  notify-completion:
    name: Notify Maintenance Completion
    runs-on: ubuntu-latest
    needs: [update-dependencies, perform-cleanup, run-optimization]
    if: always()
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    steps:
    - name: Validate notification secrets
      id: validate-notify
      shell: bash
      run: |
        slack_valid=false
        if [[ -n "${SLACK_WEBHOOK_URL}" && "${SLACK_WEBHOOK_URL}" == https://hooks.slack.com/services/* ]]; then
          slack_valid=true
        fi
        echo "slack_valid=$slack_valid" >> "$GITHUB_OUTPUT"

    - name: Send Slack notification
      if: steps.validate-notify.outputs.slack_valid == 'true'
      run: |
        DEPS_STATUS="${{ needs.update-dependencies.result }}"
        CLEANUP_STATUS="${{ needs.perform-cleanup.result }}"
        OPT_STATUS="${{ needs.run-optimization.result }}"

        if ! curl --fail --silent --show-error -X POST -H 'Content-type: application/json' \
          --data "{
            \"text\": \"ðŸ”§ Proactive Maintenance Complete\",
            \"blocks\": [
              {
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Proactive Maintenance Summary*\n\nâ€¢ Dependencies: $DEPS_STATUS\nâ€¢ Cleanup: $CLEANUP_STATUS\nâ€¢ Optimization: $OPT_STATUS\"
                }
              }
            ]
          }" \
          "$SLACK_WEBHOOK_URL"; then
          echo "::warning title=Slack notification failed::Proactive maintenance notification failed"
        fi

    - name: Log completion
      run: |
        echo "::notice title=Maintenance Complete::Proactive maintenance workflow finished"
