name: 'Deploy Live App to GitHub Pages'

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: 'Deployment strategy to use'
        required: false
        type: choice
        options:
          - auto
          - pages-direct
          - docker
          - codespaces
          - documentation-only
        default: 'auto'

concurrency:
  group: 'pages-live-deploy-${{ github.ref }}'
  cancel-in-progress: false

permissions:
  contents: write
  pages: write
  id-token: write
  pull-requests: write

jobs:
  detect-app-type:
    runs-on: ubuntu-latest
    outputs:
      app_type: ${{ steps.detect.outputs.app_type }}
      deployment_strategy: ${{ steps.detect.outputs.deployment_strategy }}
      has_frontend: ${{ steps.detect.outputs.has_frontend }}
      has_backend: ${{ steps.detect.outputs.has_backend }}
      startup_command: ${{ steps.detect.outputs.startup_command }}
    
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 'Load deployment configuration'
        id: load-config
        run: |
          CONFIG_FILE=".github/app-deployment-config.yml"
          
          if [ -f "$CONFIG_FILE" ]; then
            # Install yq if config file exists
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
            
            echo "enabled=$(yq eval '.deployment.enabled // true' "$CONFIG_FILE")" >> $GITHUB_OUTPUT
            echo "strategy=$(yq eval '.deployment.strategy // "auto"' "$CONFIG_FILE")" >> $GITHUB_OUTPUT
            echo "startup_command=$(yq eval '.deployment.startup_command // ""' "$CONFIG_FILE")" >> $GITHUB_OUTPUT
          else
            echo "enabled=true" >> $GITHUB_OUTPUT
            echo "strategy=auto" >> $GITHUB_OUTPUT
            echo "startup_command=" >> $GITHUB_OUTPUT
          fi

      - name: 'Detect application type'
        id: detect
        run: |
          echo "ðŸ” Detecting application type..."
          
          # Use manual override if specified
          STRATEGY="${{ github.event.inputs.deployment_strategy }}"
          if [ -n "$STRATEGY" ] && [ "$STRATEGY" != "auto" ]; then
            echo "deployment_strategy=$STRATEGY" >> $GITHUB_OUTPUT
            echo "app_type=manual" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Use config file strategy if specified
          CONFIG_STRATEGY="${{ steps.load-config.outputs.strategy }}"
          if [ -n "$CONFIG_STRATEGY" ] && [ "$CONFIG_STRATEGY" != "auto" ]; then
            echo "deployment_strategy=$CONFIG_STRATEGY" >> $GITHUB_OUTPUT
            echo "app_type=configured" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Auto-detect based on project files
          HAS_FRONTEND=false
          HAS_BACKEND=false
          APP_TYPE="unknown"
          DEPLOYMENT_STRATEGY="documentation-only"
          
          # Check for frontend frameworks
          if [ -f "package.json" ]; then
            if grep -q '"react"' package.json || grep -q '"next"' package.json || grep -q '"vue"' package.json || grep -q '"angular"' package.json; then
              HAS_FRONTEND=true
              APP_TYPE="frontend"
              DEPLOYMENT_STRATEGY="pages-direct"
            fi
          fi
          
          # Check for backend frameworks
          if [ -f "package.json" ]; then
            if grep -q '"express"' package.json || grep -q '"fastify"' package.json || grep -q '"koa"' package.json; then
              HAS_BACKEND=true
              APP_TYPE="backend"
              DEPLOYMENT_STRATEGY="docker"
            fi
          fi
          
          if [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then
            if grep -qE "(flask|django|fastapi)" requirements.txt 2>/dev/null || grep -qE "(flask|django|fastapi)" pyproject.toml 2>/dev/null; then
              HAS_BACKEND=true
              APP_TYPE="backend"
              DEPLOYMENT_STRATEGY="docker"
            fi
          fi
          
          # Check for static sites
          if [ -f "index.html" ] || [ -d "public" ] || [ -d "dist" ] || [ -d "build" ]; then
            if [ "$HAS_FRONTEND" = "false" ]; then
              HAS_FRONTEND=true
              APP_TYPE="static"
              DEPLOYMENT_STRATEGY="pages-direct"
            fi
          fi
          
          # Full-stack apps
          if [ "$HAS_FRONTEND" = "true" ] && [ "$HAS_BACKEND" = "true" ]; then
            APP_TYPE="fullstack"
            DEPLOYMENT_STRATEGY="docker"
          fi
          
          # CLI/Library projects
          if [ -f "setup.py" ] || [ -f "Cargo.toml" ] || grep -q '"bin"' package.json 2>/dev/null; then
            if [ "$HAS_FRONTEND" = "false" ] && [ "$HAS_BACKEND" = "false" ]; then
              APP_TYPE="cli-library"
              DEPLOYMENT_STRATEGY="documentation-only"
            fi
          fi
          
          echo "app_type=$APP_TYPE" >> $GITHUB_OUTPUT
          echo "deployment_strategy=$DEPLOYMENT_STRATEGY" >> $GITHUB_OUTPUT
          echo "has_frontend=$HAS_FRONTEND" >> $GITHUB_OUTPUT
          echo "has_backend=$HAS_BACKEND" >> $GITHUB_OUTPUT
          echo "startup_command=${{ steps.load-config.outputs.startup_command }}" >> $GITHUB_OUTPUT
          
          echo "âœ… Detected: $APP_TYPE - Strategy: $DEPLOYMENT_STRATEGY"

  deploy-pages-direct:
    needs: detect-app-type
    if: needs.detect-app-type.outputs.deployment_strategy == 'pages-direct'
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4

      - name: 'Setup Node.js'
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 'Install dependencies'
        run: |
          if [ -f "package-lock.json" ]; then
            echo "package-lock.json found, installing dependencies with npm ci"
            npm ci
          elif [ -f "package.json" ]; then
            echo "package-lock.json not found, installing dependencies with npm install"
            npm install
          else
            echo "No package.json or package-lock.json found, skipping dependency installation"
          fi

      - name: 'Build application'
        run: |
          if [ -f "package.json" ] && grep -q '"build"' package.json; then
            npm run build
          else
            echo "No build script found, skipping build step"
          fi

      - name: 'Setup Pages'
        uses: actions/configure-pages@v4

      - name: 'Determine build directory'
        id: detect-build-dir
        run: |
          app_type="${{ needs.detect-app-type.outputs.app_type }}"
          build_dir="dist"

          # Prefer framework-specific defaults when app_type is known
          if [ -n "$app_type" ]; then
            case "$app_type" in
              react)
                build_dir="build"
                ;;
              next)
                build_dir="out"
                ;;
              angular)
                if [ -d "dist" ]; then
                  first_subdir="$(ls -1 dist 2>/dev/null | head -n 1)"
                  if [ -n "$first_subdir" ] && [ -d "dist/$first_subdir" ]; then
                    build_dir="dist/$first_subdir"
                  else
                    build_dir="dist"
                  fi
                fi
                ;;
            esac
          fi

          # Fallback: use the first existing common build directory
          if [ ! -d "$build_dir" ]; then
            for dir in dist build out; do
              if [ -d "$dir" ]; then
                build_dir="$dir"
                break
              fi
            done
          fi

          echo "Using build directory: $build_dir"
          echo "build_dir=$build_dir" >> "$GITHUB_OUTPUT"

      - name: 'Upload artifact'
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ steps.detect-build-dir.outputs.build_dir }}

      - name: 'Deploy to GitHub Pages'
        id: deployment
        uses: actions/deploy-pages@v4

      - name: 'Update deployment registry'
        uses: actions/github-script@v7
        env:
          APP_TYPE: ${{ needs.detect-app-type.outputs.app_type }}
          PAGE_URL: ${{ steps.deployment.outputs.page_url }}
        with:
          script: |
            const path = 'docs/_data/app-deployments.yml';
            const { owner, repo } = context.repo;

            // Build the deployment record YAML content
            const now = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
            const repositoryFullName = `${owner}/${repo}`;
            const appType = process.env.APP_TYPE || '';
            const pageUrl = process.env.PAGE_URL || '';

            const newEntry = [
              `- repository: "${repositoryFullName}"`,
              `  app_type: "${appType}"`,
              `  deployment_strategy: "pages-direct"`,
              `  deployment_url: "${pageUrl}"`,
              `  deployed_at: "${now}"`,
              `  status: "active"`,
              `  health_check_url: "${pageUrl}"`
            ].join('\n') + '\n';

            let sha, existingContent = '';
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path,
              });
              if (!Array.isArray(data)) {
                sha = data.sha;
                existingContent = Buffer.from(data.content, 'base64').toString('utf8');
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
              // File does not exist yet; it will be created.
            }

            // Append new entry to existing content
            const content = existingContent ? existingContent + newEntry : newEntry;

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message: 'chore: update app deployment registry [skip ci]',
              content: Buffer.from(content, 'utf8').toString('base64'),
              sha,
            });

  deploy-docker:
    needs: detect-app-type
    if: needs.detect-app-type.outputs.deployment_strategy == 'docker'
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4

      - name: 'Set up Docker Buildx'
        uses: docker/setup-buildx-action@v3

      - name: 'Validate Docker credentials'
        if: github.event_name != 'pull_request'
        run: |
          if [ -z "${{ secrets.DOCKER_USERNAME }}" ] || [ -z "${{ secrets.DOCKER_PASSWORD }}" ]; then
            echo "::error::DOCKER_USERNAME or DOCKER_PASSWORD secrets are not set. Please configure these secrets in repository settings."
            exit 1
          fi

      - name: 'Log in to Docker Hub'
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: 'Extract metadata'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ github.repository }}

      - name: 'Build and push Docker image'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: 'Create embed page'
        run: |
          mkdir -p docs/live-apps
          cat > docs/live-apps/${{ github.event.repository.name }}.md << EOF
          ---
          layout: app-demo
          title: "Live Demo: ${{ github.event.repository.name }}"
          repository: "${{ github.repository }}"
          docker_image: "${{ steps.meta.outputs.tags }}"
          ---
          
          # Live Demo: ${{ github.event.repository.name }}
          
          This is a live demonstration of the application running in a Docker container.
          EOF
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/live-apps/
          git commit -m "chore: add live app embed page [skip ci]" || echo "No changes to commit"
          git push || echo "No changes to push"

      - name: 'Update deployment registry'
        uses: actions/github-script@v7
        env:
          APP_TYPE: ${{ needs.detect-app-type.outputs.app_type }}
          DOCKER_TAGS: ${{ steps.meta.outputs.tags }}
        with:
          script: |
            const path = 'docs/_data/app-deployments.yml';
            const { owner, repo } = context.repo;

            const now = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
            const repositoryFullName = `${owner}/${repo}`;
            const appType = process.env.APP_TYPE || '';
            const dockerTags = process.env.DOCKER_TAGS || '';

            const newEntry = [
              `- repository: "${repositoryFullName}"`,
              `  app_type: "${appType}"`,
              `  deployment_strategy: "docker"`,
              `  docker_image: "${dockerTags}"`,
              `  deployed_at: "${now}"`,
              `  status: "active"`,
              `  embed_url: "${context.payload.repository.html_url}/blob/main/docs/live-apps/${repo}.md"`
            ].join('\n') + '\n';

            let sha, existingContent = '';
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path,
              });
              if (!Array.isArray(data)) {
                sha = data.sha;
                existingContent = Buffer.from(data.content, 'base64').toString('utf8');
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            const content = existingContent ? existingContent + newEntry : newEntry;

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message: 'chore: update app deployment registry [skip ci]',
              content: Buffer.from(content, 'utf8').toString('base64'),
              sha,
            });

  deploy-codespaces:
    needs: detect-app-type
    if: needs.detect-app-type.outputs.deployment_strategy == 'codespaces'
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4

      - name: 'Create Codespaces configuration'
        run: |
          mkdir -p .devcontainer
          
          if [ ! -f ".devcontainer/devcontainer.json" ]; then
            cat > .devcontainer/devcontainer.json << EOF
          {
            "name": "${{ github.event.repository.name }} Development",
            "image": "mcr.microsoft.com/devcontainers/universal:2",
            "features": {
              "ghcr.io/devcontainers/features/node:1": {},
              "ghcr.io/devcontainers/features/python:1": {},
              "ghcr.io/devcontainers/features/docker-in-docker:2": {}
            },
            "postCreateCommand": "echo 'Environment ready!'",
            "forwardPorts": [3000, 5000, 8000, 8080]
          }
          EOF
          fi
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .devcontainer/
          git commit -m "chore: add Codespaces configuration [skip ci]" || echo "No changes to commit"
          git push || echo "No changes to push"

      - name: 'Update deployment registry'
        uses: actions/github-script@v7
        env:
          APP_TYPE: ${{ needs.detect-app-type.outputs.app_type }}
        with:
          script: |
            const path = 'docs/_data/app-deployments.yml';
            const { owner, repo } = context.repo;

            const now = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
            const repositoryFullName = `${owner}/${repo}`;
            const appType = process.env.APP_TYPE || '';

            const newEntry = [
              `- repository: "${repositoryFullName}"`,
              `  app_type: "${appType}"`,
              `  deployment_strategy: "codespaces"`,
              `  codespaces_url: "https://github.com/${repositoryFullName}/codespaces"`,
              `  deployed_at: "${now}"`,
              `  status: "active"`
            ].join('\n') + '\n';

            let sha, existingContent = '';
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path,
              });
              if (!Array.isArray(data)) {
                sha = data.sha;
                existingContent = Buffer.from(data.content, 'base64').toString('utf8');
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            const content = existingContent ? existingContent + newEntry : newEntry;

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message: 'chore: update app deployment registry [skip ci]',
              content: Buffer.from(content, 'utf8').toString('base64'),
              sha,
            });

  deploy-documentation-only:
    needs: detect-app-type
    if: needs.detect-app-type.outputs.deployment_strategy == 'documentation-only'
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Checkout repository'
        uses: actions/checkout@v4

      - name: 'Update deployment registry'
        uses: actions/github-script@v7
        env:
          APP_TYPE: ${{ needs.detect-app-type.outputs.app_type }}
        with:
          script: |
            const path = 'docs/_data/app-deployments.yml';
            const { owner, repo } = context.repo;

            const now = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
            const repositoryFullName = `${owner}/${repo}`;
            const appType = process.env.APP_TYPE || '';

            const newEntry = [
              `- repository: "${repositoryFullName}"`,
              `  app_type: "${appType}"`,
              `  deployment_strategy: "documentation-only"`,
              `  deployed_at: "${now}"`,
              `  status: "documentation"`,
              `  documentation_url: "${context.payload.repository.html_url}/blob/main/README.md"`
            ].join('\n') + '\n';

            let sha, existingContent = '';
            try {
              const { data } = await github.rest.repos.getContent({
                owner,
                repo,
                path,
              });
              if (!Array.isArray(data)) {
                sha = data.sha;
                existingContent = Buffer.from(data.content, 'base64').toString('utf8');
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
            }

            const content = existingContent ? existingContent + newEntry : newEntry;

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message: 'chore: update app deployment registry [skip ci]',
              content: Buffer.from(content, 'utf8').toString('base64'),
              sha,
            });
